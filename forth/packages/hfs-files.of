new-device
" hfs-files" device-name

0 value hfs+?
0 value hfsx?

0 value /alloc-block
0 value node-buf
0 value node-size
0 value root-node
40 buffer: rn-buf
0 value variable-index-keylen?
0 value constant-keylen
d# 516 buffer: my-key
200 buffer: file-extents		\ Like HFSPlusExtentRecord, but in current endianness
200 buffer: catalog-extents
200 buffer: extent-overflow-extents
0 value cur-extents
0 value volume-offset.hi		\ Offset to beginning of allocation blocks
0 value volume-offset.lo

0 value sys-parid

2 constant root-parid
3 constant extent-file#
4 constant catalog-file#

0 (field) node>next
8 (field) node>kind
A (field) node>#records

10 (field) hnode>root-node
20 (field) hnode>node-size
22 (field) hnode>max-keylen
33 (field) hnode>key-compare-type
34 (field) hnode>attributes
4 constant attr-var-kl

0 (field) mdb>sig-word
2 (field) mdb>hfs+-version
14 (field) mdb>hfs-/alloc-block
1C (field) mdb>hfs->alloc-blocks
28 (field) mdb>hfs+-/alloc-block
50 (field) mdb>hfs+-system-dir
5C (field) mdb>hfs-system-dir
7C (field) mdb>hfs-embed-sig-word
7E (field) mdb>hfs-embed-extent
86 (field) mdb>hfs-extent-overflow-extents
96 (field) mdb>hfs-catalog-extents
D0 (field) mdb>hfs+-extent-overflow-extents
120 (field) mdb>hfs+-catalog-extents

1 constant dir-record
2 constant file-record
2 (field) record>par-id
6 (field) record>name

4 (field) hfs-data>file-type
8 (field) hfs-data>file-creator
14 (field) hfs-data>file-id
1A (field) hfs-data>file-len
4A (field) hfs-data>file-extents
6 (field) hfs-data>dir-id

8 (field) hfs+-data>file-id
30 (field) hfs+-data>file-type
34 (field) hfs+-data>file-creator
5C (field) hfs+-data>file-len		\ low word of logical len
68 (field) hfs+-data>file-extents
8 (field) hfs+-data>dir-id

: do-seek				( d -- )
	volume-offset.lo volume-offset.hi d+
	" do-seek" $call-parent
;

: do-read				( addr len -- )
	" do-read" $call-parent
;


defer record>key		( addr -- key-addr key-len )
defer compare-keys		( key1-addr key1-len key2-addr key2-len -- 1 | 0 | -1 )

: alloc-node-buf		( -- )
	node-size 0= abort" no node size"
	node-buf not if
		node-size alloc-mem to node-buf
	then
;

: release-node-buf		( -- )
	node-buf if
		node-buf node-size free-mem
	then
;

: file>absolute			( d extents -- d' )
	>r /alloc-block um/mod r> rot >r >r
		( alloc-block#  R: ab-offset extents )
	begin
		dup r@ 4 + l@ - dup 0>=
	while
		nip
		r> 8 + >r
		r@ @ 0= abort" could not find required extent"
	repeat
	drop r> l@ + /alloc-block um* r> m+
;

: load-node				( node# -- )
	node-size um* cur-extents file>absolute do-seek
	node-buf node-size do-read
;

: get-node-#records		( -- u )
	node-buf node>#records w@-be
;

: node>record			( record# [0-based] -- record-addr )
	1+ 2* node-size swap - node-buf + w@-be node-buf +
;

: record>data			( rec-addr -- data-addr )
	node-buf node>kind c@ variable-index-keylen? or
	if
		record>key
	else
		record>key drop constant-keylen
	then
	+
;

: init-btree			( -- )
	release-node-buf
	40 to node-size
	rn-buf to node-buf
	0 load-node
	node-buf hnode>root-node l@-be to root-node
	node-buf hnode>node-size w@-be to node-size
	0 to node-buf
	alloc-node-buf
	
	hfs+? if
		rn-buf hnode>attributes l@-be
		attr-var-kl and 0<> dup to variable-index-keylen? not if
			rn-buf hnode>max-keylen w@-be to constant-keylen
		then
	else
		\ We can always use the record's key length value for HFS
		true to variable-index-keylen?
	then
;

0 value key-addr
0 value key-len

: match-record			( -- rec# )
	get-node-#records
	dup 0= if abort then
	dup 1 ?do
		i node>record record>key
		key-addr key-len compare-keys 1 = if
			drop i 1- unloop exit
		then
	loop
	1-
;

: search-btree			( key-addr key-len -- rec# leaf-data-addr found? )
	to key-len to key-addr
	root-node dup 0= if drop 0 0 false exit then
	begin
		load-node
		match-record dup node>record
		node-buf node>kind c@ case
			0 of true endof
			FF of false endof
			abort
		endcase
	while
		nip record>data l@-be
	repeat
	dup record>key key-addr key-len compare-keys 0=
	>r record>data r>
;


create ignore-tab-20
C allot 1 c, 1 c, 1 c, 1 c,
1A allot 1 c, 1 c, 1 c, 1 c, 1 c,
3B allot 1 c, 1 c, 1 c, 1 c, 1 c, 1 c,
90 allot


: (hfs-compare-catalog-keys)		{ addr1 len1 addr2 len2 -- 1 | 0 | -1 }
	addr1 1+ l@-be addr2 1+ l@-be
	2dup u< if
		2drop -1 exit
	then
	u> if
		1 exit
	then

	addr1 5 + c@ to len1		\ Get actual string lengths
	addr2 5 + c@ to len2
	addr1 6 + to addr1
	addr2 6 + to addr2

	len1 len2 min 0 ?do
		addr1 c@ 2* hfs-compare-tab + w@
		addr2 c@ upc 2*
		2dup u> if
			2drop 1 unloop exit
		then
		u< if
			-1 unloop exit
		then
		
		addr1 1+ to addr1
		addr2 1+ to addr2
	loop
	
	len1 len2 u> if
		1
	else
		len1 len2 u<
	then
;

\ Assumes the filename of key2 was generated by converting ASCII (chars 0-7F)
\  into Unicode.
: (hfs+-compare-catalog-keys)	{ addr1 len1 addr2 len2 -- 1 | 0 | -1 }
	addr1 l@-be addr2 l@-be
	2dup u< if
		2drop -1 exit
	then
	u> if
		1 exit
	then

	addr1 6 + to addr1
	addr2 6 + to addr2
	len1 2/ 3 - to len1
	len2 2/ 3 - to len2
	
	len2 0= if
		len1 0<> negate exit
	then
	len1 0 ?do
		addr1 w@ >r
		r@ FF00 and 2000 = if
			r@ FF and ignore-tab-20 + c@
		else
			r@ FEFF =
		then
		if
			r> drop
		else
			r@ FF00 and r> FF and lcc or 1-		\ 1- so that NULL characters come after all others
			addr2 w@ lcc 1- 2dup u< if
				2drop -1 unloop exit
			then
			u> if
				1 unloop exit
			then
			addr2 2+ to addr2
			len2 1- dup to len2
			0= if
				len1 i 1+ = if
					0 unloop exit
				else
					1 unloop exit
				then
			then
		then
		addr1 2+ to addr1
	loop
	-1
;

: (hfsx-compare-catalog-keys-cs)	{ addr1 len1 addr2 len2 -- 1 | 0 | -1 }
	addr1 l@-be addr2 l@-be
	2dup u< if
		2drop -1 exit
	then
	u> if
		1 exit
	then

	addr1 6 + addr2 6 + len1 len2 min 6 - comp
	dup 0= if
		drop
		len1 len2 u> if
			1
		else
			len1 len2 u<
		then
	then
;

: (compare-extents-keys)			( addr1 len1 addr2 len2 -- 1 | 0 | -1 )
	drop swap comp
;

: (hfs-record>key)		( addr -- key-addr key-len )
	>r r@ 1+ r> c@ 1+ waligned 1-
;

: (hfs+-record>key)		( addr -- key-addr key-len )
	>r r@ 2+ r> w@-be
;


: init-catalog-btree		( -- )
	catalog-extents to cur-extents
	init-btree
	hfs+? if
		['] (hfs+-compare-catalog-keys) to compare-keys
		hfsx? if
			rn-buf hnode>key-compare-type c@ case
				CF of endof
				BC of ['] (hfsx-compare-catalog-keys-cs) to compare-keys endof
				abort
			endcase
		then
	else
		['] (hfs-compare-catalog-keys) to compare-keys
	then
;

: init-extents-btree			( -- )
	extent-overflow-extents to cur-extents
	init-btree
	['] (compare-extents-keys) to compare-keys
;

: (hfs-copy-extents)				( this-frag-off hfs-extents addr -- next-frag-off addr' | 0 addr' )
	>r
	dup w@-be r@ l!
	dup 2 + w@-be tuck r@ 4 + l!
	dup 4 + w@-be r@ 8 + l!
	dup 6 + w@-be tuck r@ C + l!
	dup 8 + w@-be r@ 10 + l!
	A + w@-be dup r@ 14 + l!
	+ + +
	
	r@ 14 + l@ 0= if
		drop 0
	then
	
	r> 18 +
;

: (hfs+-copy-extents)			{ this-frag-off extents addr -- next-frag-off addr' | 0 addr' }
	extents addr 40 move
	le? if
		addr 40 lbflips
	then

	addr 3C + l@ if	
		this-frag-off
		8 0 ?do
			addr i 3 << 4 + + l@ +
		loop
	else
		0
	then
	
	addr 40 +
;

defer (copy-extents)			( this-frag-off extent-record addr -- next-frag-off addr' )

: copy-extents
	(copy-extents) dup 8 erase
;

: get-file-overflow-extents		{ frag-off file# addr -- }
	init-extents-btree
	my-key off
	
	file# my-key hfs+? if 2+ else 1+ then l!-be

	begin
		frag-off my-key
		hfs+? if
			6 + l!-be
			10
		else
			5 + w!-be
			7
		then
		my-key swap search-btree 0= if 2drop exit then
		nip frag-off swap addr copy-extents
		to addr
		dup to frag-off 0=
	until
;

: get-extents				( ext-rec addr file# -- )
	>r 0 -rot copy-extents over if
		r> swap get-file-overflow-extents
	else
		r> drop 2drop
	then
;


defer (find-item)
defer (find-dir)
defer .record

: (hfs-find-item)		{ addr len parid -- rec# rec-addr match? }
	len 1F min to len
	my-key 26 erase
	parid my-key 1+ l!-be
	addr len my-key 5 + pack drop
	my-key len 7 + waligned 1-
	search-btree
;

: (hfs+-find-item)		{ addr len parid -- rec# rec-addr match? }
	len FF min to len
	parid my-key l!-be
	len dup my-key 4 + w!-be
	0 ?do
		addr i + c@
		my-key i 2* 6 + + w!-be
	loop
	my-key len 2* 6 +
	search-btree
;

: find-item				( addr len parid -- rec-addr )
	(find-item) 0= if abort then nip
;

: find-first-child		( parid -- rec# | -1 )
	0 0 rot (find-item)		\ Look for the directory thread
	if
		drop
	else
		2drop -1
	then
;

: find-next-child		( rec# parid -- next-rec# | -1 )
	>r get-node-#records over 1+ u> if
		1+
	else
		drop node-buf node>next l@-be load-node 0
	then
					( trial-rec#  R: parid )
	dup node>record record>par-id l@-be r> <> if drop -1 then
;

: (hfs-find-dir)		( addr len parid -- dirid )
	find-item >r
	r@ c@ dir-record <> if abort then
	r> hfs-data>dir-id l@-be
;

: (hfs+-find-dir)		( addr len parid -- dirid )
	find-item >r
	r@ w@-be dir-record <> if abort then
	r> hfs+-data>dir-id l@-be
;

: is-file-record?		( rec-addr -- flag )
	hfs+? if w@-be else c@ then file-record =
;

: (find-filename)		( addr len parid -- rec-addr )
	find-item dup is-file-record? not if abort then
;

: find-filename			( addr len parid -- rec-addr )
	['] (find-filename) catch abort" could not find file"
;

defer data>file-len
defer data>file-extents
defer data>file-id
defer data>file-type
defer data>file-creator

: get-file-extents		( rec-addr -- file-len )
	>r
	r@ data>file-len l@-be
	r@ data>file-extents file-extents r> data>file-id l@-be
	get-extents
;

: (hfs-.record)			( rec-addr -- )
	dup record>data c@ case
		1 of cr ." [dir] " endof
		2 of cr ."       " endof
		2drop exit
	endcase
	record>name count bounds ?do
		i c@ dup 80 u< if emit else drop then
	loop
;

: (hfs+-.record)			( rec-addr -- )
	dup record>data w@-be case
		1 of cr ." [dir] " endof
		2 of cr ."       " endof
		2drop exit
	endcase
	record>name >r
	r@ 2 + r> w@-be 2*
	bounds ?do
		i w@-be dup 80 u< if emit else drop then
	2 +loop
;

: (hfs+-init-partition)		( -- catalog-ext-rec extent-ext-rec )
	['] (hfs+-copy-extents) to (copy-extents)
	['] (hfs+-record>key) to record>key
	['] (hfs+-find-item) to (find-item)
	['] (hfs+-find-dir) to (find-dir)
	['] (hfs+-.record) to .record
	['] hfs+-data>file-id to data>file-id
	['] hfs+-data>file-extents to data>file-extents
	['] hfs+-data>file-len to data>file-len
	['] hfs+-data>file-type to data>file-type
	['] hfs+-data>file-creator to data>file-creator
	
	file-extents mdb>hfs+-/alloc-block l@-be to /alloc-block
	\ no need to change volume-offset: in HFS+ allocation block 0 is block 0
	file-extents mdb>hfs+-system-dir l@-be to sys-parid

	true to hfs+?

	file-extents mdb>hfs+-catalog-extents
	file-extents mdb>hfs+-extent-overflow-extents	
;

\ We use file-extents as a temporary buffer in which to store the MDB
: init-partition			( -- recognized? )
	400 0 " do-seek" $call-parent
	file-extents 200 " do-read" $call-parent
	
	0 to volume-offset.hi
	0 to volume-offset.lo
	file-extents mdb>sig-word w@-be 4244 = if
		file-extents mdb>hfs-embed-sig-word w@-be 482B = if
			file-extents mdb>hfs-embed-extent w@-be
			file-extents mdb>hfs-/alloc-block l@-be um*
			file-extents mdb>hfs->alloc-blocks w@-be 200 * 0 d+
			to volume-offset.hi to volume-offset.lo
			400 0 do-seek
			file-extents 200 do-read
		then
	then
	
	file-extents mdb>sig-word w@-be case
		4244 of
			file-extents mdb>hfs-/alloc-block l@-be to /alloc-block
			file-extents mdb>hfs->alloc-blocks w@-be 200 um*
			to volume-offset.hi to volume-offset.lo
			file-extents mdb>hfs-system-dir l@-be to sys-parid
			['] (hfs-copy-extents) to (copy-extents)
			['] (hfs-record>key) to record>key
			['] (hfs-find-item) to (find-item)
			['] (hfs-find-dir) to (find-dir)
			['] (hfs-.record) to .record
			['] hfs-data>file-id to data>file-id
			['] hfs-data>file-extents to data>file-extents
			['] hfs-data>file-len to data>file-len
			['] hfs-data>file-type to data>file-type
			['] hfs-data>file-creator to data>file-creator
						
			false to hfs+?
			false to hfsx?
			file-extents mdb>hfs-catalog-extents
			file-extents mdb>hfs-extent-overflow-extents
		endof
		482B of
			file-extents mdb>hfs+-version w@-be 4 <> if false exit then
			false to hfsx?
			(hfs+-init-partition)
		endof
		4858 of
			file-extents mdb>hfs+-version w@-be 5 <> if false exit then
			true to hfsx?
			(hfs+-init-partition)			
		endof
		drop false exit
	endcase

	extent-overflow-extents extent-file# get-extents
	catalog-extents catalog-file# get-extents	
	true
;


( ===== public words ===== )

80 buffer: path-buf
0 value path-len

: path				( -- addr len )
	path-buf path-len
;

: convert-path		( -- )
	0 0
	{ digit# byte }
	path-buf
	my-args 80 min bounds ?do
		digit# if
			i c@ 10 digit 0= abort" bad path"
			byte 4 << or to byte
			digit# 2 = if
				byte over c! char+
				0 to digit#
			else
				digit# 1+ to digit#
			then
		else
			i c@ dup [char] % = if
				drop 1 to digit#
			else
				over c! char+
			then
		then
	loop
	path-buf - to path-len
;

: find-dir			( addr len -- parid )
	dup 0= abort" directory expected"
	2dup + 1- c@ [char] \ <> abort" directory expected"
	
	dup 2 u>= if
		over " \\" comp 0= if
			1- >r 1+ r>
			sys-parid dup 0= abort" no system directory"
		else
			root-parid
		then
	else
		root-parid
	then
	>r
	
	1- >r 1+ r>
	begin
		dup
	while
		[char] \ left-parse-string
		r> ['] (find-dir) catch abort" could not find directory" >r
	repeat
	2drop r>
;

: match-c&t?			( creator-code type-code rec-data -- flag )
	>r
	dup -1 <> if
		r@ data>file-type l@-be <> if
			r> 2drop false exit
		then
	else
		drop
	then
	dup -1 <> if
		r> data>file-creator l@-be =
	else
		r> 2drop true
	then
;

: (find-c&t)			( creator-code type-code parid -- rec-data )
	>r r@ find-first-child
	begin
		dup -1 <>
	while
		dup node>record record>data
		dup is-file-record? if
			>r 3dup drop r@ match-c&t? if
				3drop r> r> drop exit
			then
			r>
		then
		drop
		r@ find-next-child
	repeat
	r> 2drop 2drop true abort" no matching file"
;

: find-c&t			( creator-code type-code parid -- rec-data )
	['] (find-c&t) catch abort" could not find file"
;

: find-file-spec			( addr len parid -- filelen )
	0 0
	{ addr len parid creator-code type-code -- }
	len 0= abort" file expected"
	
	addr len [char] : left-parse-string
	2swap [char] , left-parse-string
	dup if
		4 <> abort" bad path" l@-be
	else
		2drop -1
	then to type-code
	dup if
		4 <> abort" bad path" l@-be
	else
		2drop -1
	then to creator-code
	
	( filename-a filename-l )
	dup if
		parid find-filename
		creator-code type-code 2 pick
		match-c&t? 0= abort" could not find file"
	else
		2drop creator-code type-code parid find-c&t
	then
	
	get-file-extents
;

: dir					( -- )
	init-catalog-btree
	path find-dir >r
	r@ find-first-child
	begin
		dup -1 <>
	while
		dup node>record .record
		r@ find-next-child
	repeat
	drop
	r> drop
;

: my-path				( -- file-a file-l dir-a dir-l )
	path tuck + swap 0 ?do
		dup i - 1- c@ [char] \ = if
			i 0= abort" no file name given"
			drop path i - 2dup + i 2swap unloop exit
		then
	loop
	abort" bad path"
;

: load					( addr -- len )
	init-catalog-btree
	my-path find-dir find-file-spec dup file-extents
	{ addr len rem extent-ptr }
	addr
	begin
		extent-ptr l@
	while
		extent-ptr l@ /alloc-block um* do-seek
		extent-ptr 4 + l@ /alloc-block * rem min
		rem over - to rem
		2dup do-read
		+
		extent-ptr 8 + to extent-ptr
	repeat
	drop len rem -
;

: open		convert-path init-partition ;
: close		;


finish-device